{
  "schema_version": "0.2.0",
  "purpose": "Combined capability checklist for structlog + loguru, ordered from simplest to most sophisticated. Intended to drive future example-code creation and fapilog comparison.",
  "ordering_rule": "Ascending sophistication: higher-order items typically depend on configuration, integration, or advanced runtime behavior.",
  "last_updated": "2026-01-12",
  "capabilities": [
    {
      "id": "basic-log-emission",
      "order": 1,
      "name": "Basic log emission (severity methods)",
      "category": "basics",
      "description": "Emit log events using standard severity methods (debug/info/warning/error/critical/exception).",
      "libraries": { "structlog": true, "loguru": true },
      "primary_entrypoints": [
        { "library": "structlog", "api": "structlog.get_logger().info/debug/warning/error/exception(...)" },
        { "library": "loguru", "api": "loguru.logger.info/debug/warning/error/exception(...)" }
      ],
      "example_scenarios": ["Hello world logging", "Logging an exception with stack trace"],
      "notes_or_pitfalls": ["Decide early whether you want structured output or human-friendly output as the default."]
    },
    {
      "id": "message-formatting",
      "order": 2,
      "name": "Message interpolation / formatting style",
      "category": "basics",
      "description": "Format messages with library-supported interpolation conventions.",
      "libraries": { "structlog": true, "loguru": true },
      "primary_entrypoints": [
        { "library": "structlog", "api": "logger.info('User %s logged in', user_id)  # printf-style" },
        { "library": "loguru", "api": "logger.info('User {} logged in', user_id)  # str.format-style" }
      ],
      "example_scenarios": ["Formatting simple values", "Formatting complex objects safely"],
      "notes_or_pitfalls": [
        "Avoid heavy string building if the log may be filtered out (see lazy logging later).",
        "structlog also supports keyword args: logger.info('logged in', user_id=user_id)"
      ]
    },
    {
      "id": "sensible-defaults",
      "order": 3,
      "name": "Sensible defaults (minimal setup)",
      "category": "basics",
      "description": "Get useful output with little-to-no configuration.",
      "libraries": { "structlog": true, "loguru": true },
      "primary_entrypoints": [
        { "library": "structlog", "api": "structlog.get_logger()  # stdout by default" },
        { "library": "loguru", "api": "from loguru import logger  # default stderr sink" }
      ],
      "example_scenarios": ["Quick start in a script", "Quick start in a small service"],
      "notes_or_pitfalls": ["Defaults are great for local dev; production often needs explicit formatting, sinks, and filtering."]
    },
    {
      "id": "extra-log-levels",
      "order": 4,
      "name": "Extra log levels (TRACE, SUCCESS)",
      "category": "basics",
      "description": "Use additional severity levels beyond the standard debug/info/warning/error/critical.",
      "libraries": { "structlog": false, "loguru": true },
      "primary_entrypoints": [
        { "library": "loguru", "api": "logger.trace('fine-grained detail'); logger.success('operation completed')" }
      ],
      "example_scenarios": ["TRACE (5) for fine-grained execution flow", "SUCCESS (25) to indicate operation completion"],
      "notes_or_pitfalls": [
        "loguru has 7 built-in levels: TRACE(5), DEBUG(10), INFO(20), SUCCESS(25), WARNING(30), ERROR(40), CRITICAL(50).",
        "structlog uses stdlib levels; custom levels require modifying structlog.stdlib._NAME_TO_LEVEL."
      ]
    },
    {
      "id": "custom-log-levels",
      "order": 5,
      "name": "Custom log levels",
      "category": "basics",
      "description": "Define application-specific log levels with custom names, severity numbers, colors, and icons.",
      "libraries": { "structlog": false, "loguru": true },
      "primary_entrypoints": [
        { "library": "loguru", "api": "logger.level('SNAKY', no=38, color='<yellow>', icon='ðŸ'); logger.log('SNAKY', 'msg')" }
      ],
      "example_scenarios": ["Domain-specific levels (AUDIT, METRIC, SECURITY)", "Modifying existing level icons/colors"],
      "notes_or_pitfalls": [
        "In loguru, cannot modify severity number after creation.",
        "structlog: requires accessing private structlog.stdlib._NAME_TO_LEVEL dict."
      ]
    },
    {
      "id": "per-call-structured-fields",
      "order": 6,
      "name": "Per-call structured fields (key-values)",
      "category": "structure",
      "description": "Attach key-value fields to a log event at the callsite.",
      "libraries": { "structlog": true, "loguru": true },
      "primary_entrypoints": [
        { "library": "structlog", "api": "logger.info('msg', request_id='...', user_id=...)" },
        { "library": "loguru", "api": "logger.bind(...).info('msg')  # or configure extra fields globally" }
      ],
      "example_scenarios": ["Attach request_id and user_id", "Attach domain-specific fields (order_id, sku, etc.)"],
      "notes_or_pitfalls": ["Keep field names consistent across services; define a naming convention early."]
    },
    {
      "id": "bound-context-loggers",
      "order": 7,
      "name": "Bound/contextual loggers (persistent fields)",
      "category": "context",
      "description": "Bind context once so subsequent log calls automatically include the bound fields.",
      "libraries": { "structlog": true, "loguru": true },
      "primary_entrypoints": [
        { "library": "structlog", "api": "logger = logger.bind(request_id='...'); logger.unbind('key'); logger.try_unbind('key'); logger.new(...)" },
        { "library": "loguru", "api": "logger = logger.bind(request_id='...')" }
      ],
      "example_scenarios": ["Request-scoped logger in a web handler", "Service-scoped logger with service metadata"],
      "notes_or_pitfalls": [
        "Be careful not to leak context across requests (especially in async servers).",
        "structlog's try_unbind() doesn't raise if key is missing."
      ]
    },
    {
      "id": "scoped-context-manager",
      "order": 8,
      "name": "Scoped context (context manager)",
      "category": "context",
      "description": "Temporarily add context for a block of code and automatically revert afterwards.",
      "libraries": { "structlog": true, "loguru": true },
      "primary_entrypoints": [
        { "library": "structlog", "api": "with structlog.contextvars.bound_contextvars(request_id='...'): ...  # also works as decorator" },
        { "library": "loguru", "api": "with logger.contextualize(request_id='...'): ..." }
      ],
      "example_scenarios": ["Span-like block logging", "Add temporary 'phase' field inside a pipeline stage"],
      "notes_or_pitfalls": [
        "structlog's bound_contextvars() added in v21.4.0.",
        "Both use contextvars under the hood for async safety."
      ]
    },
    {
      "id": "pretty-console-output",
      "order": 9,
      "name": "Human-friendly console output (incl. color)",
      "category": "rendering",
      "description": "Render logs in a developer-friendly format suitable for terminals.",
      "libraries": { "structlog": true, "loguru": true },
      "primary_entrypoints": [
        { "library": "structlog", "api": "structlog.dev.ConsoleRenderer(colors=True, ...)" },
        { "library": "loguru", "api": "logger.add(sys.stderr, colorize=True, format='...')" }
      ],
      "example_scenarios": ["Local dev console logs", "Readable exceptions during debugging"],
      "notes_or_pitfalls": ["Color/markup should usually be disabled in JSON/production sinks."]
    },
    {
      "id": "multiple-outputs",
      "order": 10,
      "name": "Multiple outputs (sinks/handlers)",
      "category": "sinks",
      "description": "Send logs to multiple destinations and dynamically add/remove outputs.",
      "libraries": { "structlog": true, "loguru": true },
      "primary_entrypoints": [
        { "library": "loguru", "api": "sink_id = logger.add(...); logger.remove(sink_id)" },
        { "library": "structlog", "api": "stdlib logging handlers + structlog ProcessorFormatter integration" }
      ],
      "example_scenarios": ["Console + file", "Console + JSON to stdout for collectors"],
      "notes_or_pitfalls": [
        "In structlog, routing is commonly delegated to stdlib logging configuration.",
        "loguru's add() returns an ID for later removal."
      ]
    },
    {
      "id": "file-logging",
      "order": 11,
      "name": "File logging",
      "category": "sinks",
      "description": "Write logs to files.",
      "libraries": { "structlog": true, "loguru": true },
      "primary_entrypoints": [
        { "library": "loguru", "api": "logger.add('app.log', ...)" },
        { "library": "structlog", "api": "logging.FileHandler + ProcessorFormatter/JSONRenderer/ConsoleRenderer pipeline" }
      ],
      "example_scenarios": ["Single rolling file", "Separate file per service instance"],
      "notes_or_pitfalls": ["Avoid blocking I/O on the request path unless you use queueing/enqueue patterns."]
    },
    {
      "id": "rotation-retention-compression",
      "order": 12,
      "name": "Rotation / retention / compression",
      "category": "sinks",
      "description": "Automatically rotate log files, keep a retention window, and optionally compress archives.",
      "libraries": { "structlog": false, "loguru": true },
      "primary_entrypoints": [
        { "library": "loguru", "api": "logger.add('file.log', rotation='10 MB', retention='7 days', compression='zip')" }
      ],
      "example_scenarios": ["Size-based rotation", "Time-based retention + compression"],
      "notes_or_pitfalls": [
        "Rotation policies should align with your container/log shipping strategy.",
        "structlog relies on stdlib RotatingFileHandler/TimedRotatingFileHandler."
      ]
    },
    {
      "id": "filtering-and-routing",
      "order": 13,
      "name": "Filtering & routing logic",
      "category": "filtering",
      "description": "Filter events by module, level, or custom rules; route different subsets to different outputs.",
      "libraries": { "structlog": true, "loguru": true },
      "primary_entrypoints": [
        { "library": "loguru", "api": "logger.add(..., filter=callable|str|dict, level='INFO')" },
        { "library": "structlog", "api": "structlog.make_filtering_bound_logger(min_level); raise structlog.DropEvent in processor" }
      ],
      "example_scenarios": ["Only ERROR to one sink, INFO+ to another", "Drop noisy libraries/modules"],
      "notes_or_pitfalls": [
        "Define a consistent filtering policy across services to avoid debugging blind spots.",
        "structlog's DropEvent exception allows conditional event dropping in processors."
      ]
    },
    {
      "id": "callsite-enrichment",
      "order": 14,
      "name": "Callsite enrichment (filename, function, line)",
      "category": "structure",
      "description": "Automatically add source code location information to log events.",
      "libraries": { "structlog": true, "loguru": true },
      "primary_entrypoints": [
        { "library": "structlog", "api": "structlog.processors.CallsiteParameterAdder(parameters=[CallsiteParameter.FILENAME, .FUNC_NAME, .LINENO, .MODULE, .THREAD, .PROCESS, .QUAL_NAME])" },
        { "library": "loguru", "api": "format string placeholders: {file}, {function}, {line}, {module}, {name}, {thread}, {process}" }
      ],
      "example_scenarios": ["Debug logs with file:line info", "Include function name for tracing"],
      "notes_or_pitfalls": [
        "structlog's QUAL_NAME (qualified name with class) added in v25.5.0, Python 3.11+ only.",
        "loguru includes these by default in format; structlog requires explicit processor."
      ]
    },
    {
      "id": "async-safe-context-propagation",
      "order": 15,
      "name": "Async-safe context propagation (contextvars)",
      "category": "context",
      "description": "Maintain request/task-local context across async boundaries without manual threading of fields.",
      "libraries": { "structlog": true, "loguru": true },
      "primary_entrypoints": [
        { "library": "structlog", "api": "structlog.contextvars.bind_contextvars(...); unbind_contextvars(...); clear_contextvars(); merge_contextvars processor" },
        { "library": "loguru", "api": "with logger.contextualize(...): ...  # uses contextvars internally" }
      ],
      "example_scenarios": ["FastAPI request_id propagation", "Background tasks inheriting trace context"],
      "notes_or_pitfalls": [
        "Be explicit about clearing contextvars at request end to prevent leakage.",
        "structlog has more granular control (separate bind/unbind/clear functions).",
        "loguru's contextualize() is context-manager only, but is fully async-safe.",
        "Neither auto-propagates to ThreadPoolExecutor threads; use asyncio.to_thread() for propagation."
      ]
    },
    {
      "id": "stdlib-logging-interop",
      "order": 16,
      "name": "Interop with Python stdlib logging",
      "category": "integration",
      "description": "Bridge into/from the standard logging module ecosystem (handlers, formatters, libraries).",
      "libraries": { "structlog": true, "loguru": true },
      "primary_entrypoints": [
        { "library": "structlog", "api": "structlog.stdlib.ProcessorFormatter; wrap_for_formatter(); structlog.stdlib.BoundLogger" },
        { "library": "loguru", "api": "logger.add(logging.Handler(...)); InterceptHandler pattern for capturing stdlib logs" }
      ],
      "example_scenarios": ["Use syslog/HTTP handlers via stdlib", "Capture logs from third-party libraries"],
      "notes_or_pitfalls": [
        "Interop is often where duplicate logs happen; plan propagation/disable_existing_loggers carefully.",
        "structlog designed as stdlib wrapper; loguru requires InterceptHandler pattern to capture stdlib."
      ]
    },
    {
      "id": "json-structured-output",
      "order": 17,
      "name": "Structured serialization (JSON output)",
      "category": "structure",
      "description": "Emit logs as JSON for ingestion by log processors/observability stacks.",
      "libraries": { "structlog": true, "loguru": true },
      "primary_entrypoints": [
        { "library": "structlog", "api": "structlog.processors.JSONRenderer()" },
        { "library": "loguru", "api": "logger.add(..., serialize=True)" }
      ],
      "example_scenarios": ["JSON to stdout in containers", "JSON file sink for ingestion"],
      "notes_or_pitfalls": ["Ensure timestamps, level, logger name, and trace fields are consistently present."]
    },
    {
      "id": "structured-exception-serialization",
      "order": 18,
      "name": "Structured exception serialization",
      "category": "structure",
      "description": "Serialize exception tracebacks as structured data (JSON-compatible) rather than plain text.",
      "libraries": { "structlog": true, "loguru": true },
      "primary_entrypoints": [
        { "library": "structlog", "api": "structlog.processors.dict_tracebacks; ExceptionRenderer(ExceptionDictTransformer(show_locals=...))" },
        { "library": "loguru", "api": "serialize=True includes exception info in JSON structure" }
      ],
      "example_scenarios": ["Machine-parseable exception data for log aggregators", "Include local variables for debugging"],
      "notes_or_pitfalls": [
        "structlog's dict_tracebacks provides highly configurable structured exceptions.",
        "loguru's serialize=True includes exceptions but with less granular control."
      ]
    },
    {
      "id": "event-processing-pipeline",
      "order": 19,
      "name": "Event/record mutation pipeline",
      "category": "processing",
      "description": "Transform/enrich/remove fields before rendering or writing to sinks (extensible processing).",
      "libraries": { "structlog": true, "loguru": true },
      "primary_entrypoints": [
        { "library": "structlog", "api": "processors=[...custom callables...]; each receives (logger, method_name, event_dict)" },
        { "library": "loguru", "api": "logger.patch(patcher_function)  # patcher receives record dict" }
      ],
      "example_scenarios": ["Add service/version/env fields globally", "Redact secrets (password, token)"],
      "notes_or_pitfalls": [
        "Redaction should happen as early as possible; avoid leaking secrets to any sink.",
        "structlog processors are the core design principle; loguru's patch() is more limited."
      ]
    },
    {
      "id": "per-call-behavior-options",
      "order": 20,
      "name": "Per-call behavior modifications (opt)",
      "category": "processing",
      "description": "Modify logging behavior for individual calls (lazy eval, depth adjustment, raw output, etc.).",
      "libraries": { "structlog": false, "loguru": true },
      "primary_entrypoints": [
        { "library": "loguru", "api": "logger.opt(lazy=True, depth=N, raw=True, colors=True, record=True, capture=False, exception=...)" }
      ],
      "example_scenarios": [
        "lazy=True: defer expensive computation until log is emitted",
        "depth=1: adjust call stack for accurate caller info in wrappers",
        "raw=True: bypass sink formatting",
        "colors=True: per-message color markup"
      ],
      "notes_or_pitfalls": [
        "Cannot chain opt() calls; last one wins.",
        "structlog achieves some of these via processors or callsite patterns."
      ]
    },
    {
      "id": "performance-avoid-work",
      "order": 21,
      "name": "Performance patterns (avoid paying for filtered logs)",
      "category": "performance",
      "description": "Avoid expensive computations when the log call won't be emitted.",
      "libraries": { "structlog": true, "loguru": true },
      "primary_entrypoints": [
        { "library": "loguru", "api": "logger.opt(lazy=True).debug('...{x}...', x=lambda: expensive())" },
        { "library": "structlog", "api": "make_filtering_bound_logger(...) filters at method-call time before processing" }
      ],
      "example_scenarios": ["Lazy formatting", "Skip debug-only payload serialization"],
      "notes_or_pitfalls": [
        "Document your team's preferred pattern so people don't reintroduce overhead.",
        "loguru's lazy=True is explicit; structlog filters early but still evaluates args."
      ]
    },
    {
      "id": "exception-catching-decorator",
      "order": 22,
      "name": "Exception catching decorator/context manager",
      "category": "diagnostics",
      "description": "Automatically catch and log exceptions from functions or code blocks.",
      "libraries": { "structlog": false, "loguru": true },
      "primary_entrypoints": [
        { "library": "loguru", "api": "@logger.catch; @logger.catch(exception=ValueError, reraise=True, message='...', onerror=callback)" }
      ],
      "example_scenarios": [
        "Wrap main() to catch all unhandled exceptions",
        "Log and continue (reraise=False) vs log and propagate (reraise=True)",
        "Custom exit code on error with onerror callback"
      ],
      "notes_or_pitfalls": [
        "Default reraise=False swallows exceptions; be explicit about desired behavior.",
        "Pretty tracebacks may not work correctly with async functions decorated with @logger.catch.",
        "structlog requires manual try/except with logger.exception()."
      ]
    },
    {
      "id": "advanced-tracebacks-diagnostics",
      "order": 23,
      "name": "Advanced exception diagnostics",
      "category": "diagnostics",
      "description": "Enhanced tracebacks and introspective diagnostics for debugging.",
      "libraries": { "structlog": true, "loguru": true },
      "primary_entrypoints": [
        { "library": "loguru", "api": "logger.add(..., backtrace=True, diagnose=True)" },
        { "library": "structlog", "api": "ConsoleRenderer(exception_formatter=RichTracebackFormatter(show_locals=True, max_frames=100))" }
      ],
      "example_scenarios": ["Developer mode with enhanced tracebacks", "Production mode without sensitive locals"],
      "notes_or_pitfalls": [
        "Diagnostics can expose sensitive data; keep diagnose=False / show_locals=False in production.",
        "structlog's RichTracebackFormatter added in v23.2.0; requires Rich library.",
        "loguru's backtrace extends trace upward beyond catch point."
      ]
    },
    {
      "id": "global-exception-handler",
      "order": 24,
      "name": "Global uncaught exception handler",
      "category": "diagnostics",
      "description": "Intercept and log uncaught exceptions at the application level.",
      "libraries": { "structlog": false, "loguru": true },
      "primary_entrypoints": [
        { "library": "loguru", "api": "sys.excepthook integration; @logger.catch on main()" }
      ],
      "example_scenarios": ["Ensure all crashes are logged", "Custom formatting for unhandled exceptions"],
      "notes_or_pitfalls": [
        "structlog relies on stdlib sys.excepthook configuration.",
        "Thread exceptions need threading.excepthook (Python 3.8+)."
      ]
    },
    {
      "id": "async-multiprocess-safe-delivery",
      "order": 25,
      "name": "Async + multiprocess-safe delivery (queueing, async sinks)",
      "category": "concurrency",
      "description": "Non-blocking logging with queued delivery and support for async sinks.",
      "libraries": { "structlog": true, "loguru": true },
      "primary_entrypoints": [
        { "library": "loguru", "api": "logger.add(..., enqueue=True); coroutine sinks; await logger.complete()" },
        { "library": "structlog", "api": "async bound logger methods (ainfo/adebug/etc.); stdlib QueueHandler" }
      ],
      "example_scenarios": ["Avoid blocking in request path", "Central log writer process via queue"],
      "notes_or_pitfalls": [
        "Queueing can reorder logs slightly; include timestamps/sequence ids if needed.",
        "loguru's complete() has known deadlock issues in some async contexts due to threading.Lock.",
        "For multiprocess, loguru's enqueue=True is simpler; structlog needs QueueHandler setup."
      ]
    },
    {
      "id": "logging-failure-containment",
      "order": 26,
      "name": "Failure containment (sink errors don't crash app)",
      "category": "reliability",
      "description": "Prevent exceptions raised by logging sinks from taking down your process.",
      "libraries": { "structlog": false, "loguru": true },
      "primary_entrypoints": [
        { "library": "loguru", "api": "logger.add(..., catch=True)" }
      ],
      "example_scenarios": ["Broken file permissions", "Network sink temporarily unavailable"],
      "notes_or_pitfalls": [
        "If you swallow sink failures, ensure you still emit a health signal/metric elsewhere.",
        "structlog: sink exceptions propagate; wrap in try/except if needed."
      ]
    },
    {
      "id": "testing-capture-logs",
      "order": 27,
      "name": "Testing support (capture structured logs)",
      "category": "testing",
      "description": "Capture emitted events in tests for assertions without parsing strings.",
      "libraries": { "structlog": true, "loguru": false },
      "primary_entrypoints": [
        { "library": "structlog", "api": "structlog.testing.capture_logs(); LogCapture processor" }
      ],
      "example_scenarios": ["Assert a warning log is emitted with expected fields", "Assert no error logs were emitted"],
      "notes_or_pitfalls": [
        "Keep tests resilient: assert on keys/values, not on full rendered output strings.",
        "loguru: no built-in support, but can override pytest's caplog fixture or use pytest-loguru package.",
        "loguru workaround: logger.add(output_list.append, ...) to capture to a list."
      ]
    },
    {
      "id": "type-hints-static-typing",
      "order": 28,
      "name": "Type hints / static typing support",
      "category": "developer-experience",
      "description": "Provide type annotations for IDE autocompletion and static type checkers (mypy, pyright).",
      "libraries": { "structlog": true, "loguru": true },
      "primary_entrypoints": [
        { "library": "structlog", "api": "structlog.stdlib.get_logger() -> BoundLogger; structlog.typing.BindableLogger protocol" },
        { "library": "loguru", "api": "from loguru import logger  # typed, but less granular" }
      ],
      "example_scenarios": ["IDE autocompletion for log methods", "Mypy checking of logger usage"],
      "notes_or_pitfalls": [
        "structlog.get_logger() returns Any; use structlog.stdlib.get_logger() for proper typing.",
        "structlog has comprehensive type hints since v20.2.0.",
        "loguru has basic typing but less flexibility for custom configurations."
      ]
    },
    {
      "id": "deep-configuration-and-factories",
      "order": 29,
      "name": "Deep configuration (factories, wrappers, caching)",
      "category": "configuration",
      "description": "Control logger construction and behavior at an architectural level (wrappers, factories, caching, processor chains).",
      "libraries": { "structlog": true, "loguru": true },
      "primary_entrypoints": [
        { "library": "structlog", "api": "structlog.configure(processors=..., wrapper_class=..., logger_factory=..., cache_logger_on_first_use=...)" },
        { "library": "loguru", "api": "logger.configure(handlers=[...], levels=[...], extra={...}, patcher=..., activation=[...])" }
      ],
      "example_scenarios": ["Standardize logging across many services", "Environment-based config (dev vs prod)"],
      "notes_or_pitfalls": [
        "Centralize configuration to avoid divergent behavior across services.",
        "structlog's wrapper_class allows complete customization of bound logger behavior.",
        "loguru's configure() is simpler but less flexible than structlog's processor chain model."
      ]
    }
  ],
  "developer_experience": {
    "description": "Qualitative aspects of using each library that cut across individual capabilities.",
    "aspects": [
      {
        "id": "dx-time-to-first-log",
        "name": "Time to first log",
        "description": "How quickly can a developer go from zero to working log output?",
        "comparison": {
          "structlog": {
            "rating": "good",
            "lines_of_code": "2-3 lines for basic output, 10-20 lines for production-ready config",
            "notes": "Requires structlog.configure() call for anything beyond defaults. Defaults emit to stdout with key=value format."
          },
          "loguru": {
            "rating": "excellent",
            "lines_of_code": "1 line (from loguru import logger; logger.info('hi'))",
            "notes": "Works immediately with attractive colored output to stderr. Zero configuration needed for basic use."
          }
        }
      },
      {
        "id": "dx-learning-curve",
        "name": "Learning curve",
        "description": "How much must a developer learn before being productive?",
        "comparison": {
          "structlog": {
            "rating": "moderate",
            "notes": "Core concepts (processors, bound loggers, wrappers) require understanding. Documentation is thorough but can feel overwhelming. The stdlib integration adds another layer of complexity."
          },
          "loguru": {
            "rating": "gentle",
            "notes": "Single logger object, intuitive API (add/remove/bind). Most features discoverable through IDE autocomplete. Documentation is friendly and example-driven."
          }
        }
      },
      {
        "id": "dx-documentation-quality",
        "name": "Documentation quality",
        "description": "Clarity, completeness, and navigability of official docs.",
        "comparison": {
          "structlog": {
            "rating": "comprehensive",
            "url": "https://www.structlog.org/",
            "notes": "Extensive docs covering all use cases. Strong on 'why' and architectural rationale. Can be dense for newcomers. Good cookbook and recipes section."
          },
          "loguru": {
            "rating": "excellent",
            "url": "https://loguru.readthedocs.io/",
            "notes": "Clear, example-heavy documentation. Great 'Overview' page that covers most use cases. Good migration guide from stdlib. Less depth on advanced patterns."
          }
        }
      },
      {
        "id": "dx-error-messages",
        "name": "Error message clarity",
        "description": "How helpful are error messages when something goes wrong?",
        "comparison": {
          "structlog": {
            "rating": "good",
            "notes": "Processor chain errors can be cryptic (stack traces through multiple processors). Configuration errors are usually clear. reset_defaults() helps recover from bad state."
          },
          "loguru": {
            "rating": "excellent",
            "notes": "Clear error messages with suggestions. The diagnose=True option shows local variables in tracebacks. Sink errors are caught and reported cleanly by default."
          }
        }
      },
      {
        "id": "dx-ide-experience",
        "name": "IDE experience (autocomplete, go-to-definition)",
        "description": "How well does the library work with modern IDEs?",
        "comparison": {
          "structlog": {
            "rating": "good",
            "notes": "Full type hints since v20.2.0. structlog.get_logger() returns Any (by design), so use structlog.stdlib.get_logger() for proper typing. Processors are well-typed."
          },
          "loguru": {
            "rating": "good",
            "notes": "Basic type hints present. Single logger instance means good autocomplete. opt() parameters well-documented in IDE tooltips."
          }
        }
      },
      {
        "id": "dx-api-consistency",
        "name": "API consistency and intuitiveness",
        "description": "Is the API predictable and easy to remember?",
        "comparison": {
          "structlog": {
            "rating": "good",
            "notes": "Consistent processor-based model throughout. bind/unbind/new pattern is clean. Multiple ways to achieve same goal can confuse (contextvars vs bound loggers). stdlib integration adds API surface."
          },
          "loguru": {
            "rating": "excellent",
            "notes": "Extremely consistent: one logger, add() for sinks, bind() for context, opt() for per-call options. Method chaining works intuitively. Almost everything returns the logger for chaining."
          }
        }
      },
      {
        "id": "dx-migration-from-stdlib",
        "name": "Migration from stdlib logging",
        "description": "How easy is it to adopt in an existing codebase using stdlib logging?",
        "comparison": {
          "structlog": {
            "rating": "excellent",
            "notes": "Designed as a stdlib wrapper. Can incrementally adopt: configure structlog to output through stdlib handlers. ProcessorFormatter allows mixing structlog and stdlib loggers. Existing logging.getLogger() calls can coexist."
          },
          "loguru": {
            "rating": "good",
            "notes": "Requires InterceptHandler pattern to capture stdlib logs. Can coexist but needs explicit bridging. Migration guide in docs. All-or-nothing feel compared to structlog's gradual adoption."
          }
        }
      },
      {
        "id": "dx-debugging-logging-itself",
        "name": "Debugging the logging system",
        "description": "When logs aren't appearing, how easy is it to diagnose why?",
        "comparison": {
          "structlog": {
            "rating": "moderate",
            "notes": "No built-in diagnostic mode. Common issues: processor chain order, missing merge_contextvars, stdlib handler level too high. reset_defaults() helps. Can inspect structlog.get_config()."
          },
          "loguru": {
            "rating": "good",
            "notes": "diagnose=True helps with exceptions. Can list active handlers. LOGURU_AUTOINIT=false for debugging startup. Common issues: removed default handler without adding new one."
          }
        }
      },
      {
        "id": "dx-configuration-file-support",
        "name": "Configuration file support (YAML/JSON/TOML)",
        "description": "Can logging be configured via external files without code changes?",
        "comparison": {
          "structlog": {
            "rating": "limited",
            "notes": "No native support. Configuration is Python code via structlog.configure(). Third-party structlog-config package exists. Can build custom loader that reads files and calls configure()."
          },
          "loguru": {
            "rating": "limited-with-addon",
            "notes": "No native support. Environment variables (LOGURU_FORMAT, LOGURU_LEVEL, etc.) provide some external control. loguru-config package adds YAML/JSON/TOML support with cfg://, ext://, env:// references."
          }
        }
      },
      {
        "id": "dx-environment-variable-config",
        "name": "Environment variable configuration",
        "description": "Can behavior be controlled via environment variables?",
        "comparison": {
          "structlog": {
            "rating": "manual",
            "notes": "No built-in env var support. Must implement: read os.environ, pass to configure(). Common pattern: ENVIRONMENT=production to switch renderers."
          },
          "loguru": {
            "rating": "excellent",
            "notes": "Extensive built-in support. LOGURU_FORMAT, LOGURU_LEVEL, LOGURU_COLORIZE, LOGURU_SERIALIZE, LOGURU_AUTOINIT, LOGURU_[LEVEL]_COLOR, LOGURU_[LEVEL]_ICON, etc."
          }
        }
      },
      {
        "id": "dx-runtime-reconfiguration",
        "name": "Runtime reconfiguration",
        "description": "Can logging behavior be changed without restarting the application?",
        "comparison": {
          "structlog": {
            "rating": "limited",
            "notes": "Can call structlog.configure() again, but doesn't affect already-cached loggers if cache_logger_on_first_use=True. reset_defaults() available. Stdlib handlers can be modified at runtime."
          },
          "loguru": {
            "rating": "good",
            "notes": "logger.remove()/add() allows dynamic sink management. Can change levels per-sink. logger.disable()/enable() for module-level control. No hot-reload of format strings."
          }
        }
      }
    ],
    "framework_integrations": {
      "description": "Official and community integrations with popular Python frameworks.",
      "frameworks": [
        {
          "name": "FastAPI",
          "structlog": {
            "support": "community",
            "packages": ["fastapi-structlog", "asgi-correlation-id"],
            "notes": "Requires middleware setup for request context. contextvars work across async/sync boundaries with care. Well-documented patterns available.",
            "complexity": "moderate"
          },
          "loguru": {
            "support": "community",
            "packages": ["fastapi-mvc-loguru-demo patterns"],
            "notes": "Requires InterceptHandler to capture uvicorn logs. contextualize() works for request context. Simpler initial setup but less structured.",
            "complexity": "low-moderate"
          }
        },
        {
          "name": "Django",
          "structlog": {
            "support": "official",
            "packages": ["django-structlog"],
            "notes": "django-structlog provides middleware, celery integration, and request context. Integrates with Django's LOGGING dict config.",
            "complexity": "low"
          },
          "loguru": {
            "support": "community",
            "packages": [],
            "notes": "Manual integration via middleware. Must bridge Django's logging system. No official package.",
            "complexity": "moderate"
          }
        },
        {
          "name": "Flask",
          "structlog": {
            "support": "documented",
            "packages": [],
            "notes": "Official docs show Flask integration patterns. Works with before_request hooks and g object or contextvars.",
            "complexity": "low"
          },
          "loguru": {
            "support": "community",
            "packages": [],
            "notes": "Works with Flask's before_request hooks. Must intercept werkzeug logging separately.",
            "complexity": "low"
          }
        },
        {
          "name": "Celery",
          "structlog": {
            "support": "official",
            "packages": ["django-structlog (includes Celery support)"],
            "notes": "django-structlog provides celery_prerun/postrun signal handlers. Can propagate context to tasks.",
            "complexity": "low-moderate"
          },
          "loguru": {
            "support": "community",
            "packages": [],
            "notes": "Manual signal handler setup. enqueue=True important for multiprocess safety.",
            "complexity": "moderate"
          }
        }
      ]
    },
    "observability_integrations": {
      "description": "Integration with observability platforms and APM tools.",
      "platforms": [
        {
          "name": "Datadog",
          "structlog": {
            "support": "official",
            "method": "ddtrace auto-instrumentation or manual tracer_injection processor",
            "notes": "Automatic trace correlation with dd.trace_id, dd.span_id, dd.env, dd.service, dd.version injection. Works with JSONRenderer for log ingestion."
          },
          "loguru": {
            "support": "official",
            "method": "ddtrace auto-patching with DD_LOGS_INJECTION=true",
            "notes": "Automatic patching via ddtrace-run. LOGURU_SERIALIZE=true for JSON output. Some quirks with sink ordering."
          }
        },
        {
          "name": "Sentry",
          "structlog": {
            "support": "manual",
            "method": "Custom processor to capture breadcrumbs or send to Sentry SDK",
            "notes": "No official integration. Can create processor that calls sentry_sdk.capture_message() or adds breadcrumbs."
          },
          "loguru": {
            "support": "manual",
            "method": "Custom sink that sends to Sentry SDK",
            "notes": "logger.add(sentry_sink) pattern. Can use logger.catch() with Sentry integration for exception capture."
          }
        },
        {
          "name": "OpenTelemetry",
          "structlog": {
            "support": "manual",
            "method": "Processor to inject trace_id/span_id from opentelemetry.trace",
            "notes": "Can correlate logs with OTel traces. JSONRenderer output works with OTel collectors."
          },
          "loguru": {
            "support": "manual",
            "method": "patch() function to inject OTel context",
            "notes": "Similar manual integration. serialize=True output compatible with OTel log ingestion."
          }
        },
        {
          "name": "ELK Stack (Elasticsearch/Logstash/Kibana)",
          "structlog": {
            "support": "native",
            "method": "JSONRenderer to stdout, collected by Filebeat/Fluentd",
            "notes": "Structured JSON output is ELK-ready. Field names can be customized via processors."
          },
          "loguru": {
            "support": "native",
            "method": "serialize=True to stdout, collected by Filebeat/Fluentd",
            "notes": "JSON output compatible with ELK. Less control over field naming than structlog."
          }
        }
      ]
    },
    "ecosystem_and_community": {
      "structlog": {
        "github_stars": "~3.5k",
        "maintenance": "Active, maintained by Hynek Schlawack",
        "release_cadence": "Regular releases, good changelog",
        "community_packages": [
          "django-structlog",
          "structlog-config",
          "fastapi-structlog"
        ],
        "philosophy": "Explicit is better than implicit. Processor chains give full control. Integrates with stdlib rather than replacing it."
      },
      "loguru": {
        "github_stars": "~20k",
        "maintenance": "Active, maintained by Delgan",
        "release_cadence": "Regular releases",
        "community_packages": [
          "loguru-config",
          "pytest-loguru",
          "loguru-mypy (stubs)"
        ],
        "philosophy": "Make logging stupidly simple. Batteries included. One logger to rule them all. Replace stdlib rather than wrap it."
      }
    },
    "summary": {
      "choose_structlog_when": [
        "You need fine-grained control over log processing",
        "You're integrating with existing stdlib logging infrastructure",
        "You want robust testing utilities (capture_logs)",
        "You need contextvars with granular bind/unbind control",
        "You're building a large system where consistency matters more than simplicity",
        "You want strong typing support"
      ],
      "choose_loguru_when": [
        "You want to get started quickly with minimal configuration",
        "You prefer a simple, intuitive API over flexibility",
        "You need built-in file rotation, retention, and compression",
        "You want rich exception diagnostics out of the box",
        "Environment variable configuration is important",
        "You're building smaller services or scripts"
      ]
    }
  }
}
