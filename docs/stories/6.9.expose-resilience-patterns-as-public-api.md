# Story 6.9: Expose Resilience Patterns as Public API

## Status: CANCELLED

> **Superseded by:** Story 6.7 (Simplify Resilience Infrastructure + Add Tenacity Compatibility)

## Cancellation Reason

Story 6.7 decided on the **"Lean Internal + Protocol Escape Hatch"** approach:

1. **Remove** `fallback.py` entirely — not needed for logging
2. **Remove** `AsyncCircuitBreaker` and `CircuitBreakerManager` — unused
3. **Simplify** `retry.py` to logging-appropriate defaults
4. **Add** `RetryCallable` protocol for Tenacity compatibility

This approach was chosen because:

- **Logging libraries should minimize dependencies** — Adding Tenacity would increase conflict risk
- **Retry for logging has narrow requirements** — Simple exponential backoff suffices
- **Protocol enables Tenacity for power users** — Without forcing a dependency on everyone
- **Fapilog is a logging library, not a resilience framework** — Users who need full resilience patterns should use Tenacity, pybreaker, etc.

## What Happens to This Story

The work originally planned for this story is now split:

| Original Plan                       | New Outcome                                                |
| ----------------------------------- | ---------------------------------------------------------- |
| Expose `@retry` decorator           | **REMOVED** — Tenacity's is better                         |
| Expose `@circuit_breaker` decorator | **REMOVED** — Use pybreaker if needed                      |
| Expose `@fallback` decorator        | **REMOVED** — Use custom implementation if needed          |
| Expose predefined configs           | **DOCUMENTED** — As patterns in docs, not exported symbols |
| Create `fapilog.resilience` module  | **NOT CREATED** — Out of scope for logging library         |

## For Enterprise Users Who Need Resilience

Story 6.7 includes documentation for Tenacity integration:

```python
# Using Tenacity with Fapilog sinks (documented pattern)
from tenacity import AsyncRetrying, stop_after_attempt, wait_exponential

class TenacityAdapter:
    def __init__(self, retrying: AsyncRetrying):
        self._retrying = retrying

    async def __call__(self, func, *args, **kwargs):
        async for attempt in self._retrying:
            with attempt:
                return await func(*args, **kwargs)

# Usage with Fapilog sink
sink = HttpSink(
    endpoint="https://api.example.com/logs",
    retry=TenacityAdapter(AsyncRetrying(
        stop=stop_after_attempt(5),
        wait=wait_exponential(multiplier=1, max=30),
    ))
)
```

This provides enterprise users with:

- Full Tenacity feature set (callbacks, custom conditions, etc.)
- Consistency with their existing retry patterns
- No forced dependency on Fapilog's implementation

## See Also

- [Story 6.7: Simplify Resilience Infrastructure + Add Tenacity Compatibility](./6.7.decide-resilience-api-fate.md)
