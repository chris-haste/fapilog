name: Release (tag-driven)

on:
  push:
    tags:
      - "v*"

permissions:
  contents: write
  id-token: write

env:
  PYTHON_VERSION: "3.11"

jobs:
  changelog-check:
    name: Validate changelog
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Extract version from tag
        id: version
        run: |
          TAG="${GITHUB_REF##*/}"
          VERSION="${TAG#v}"
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Validating changelog for version: $VERSION"

      - name: Validate changelog has version entry
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          # Check if changelog has entry for this exact version
          if ! grep -qE "^\#\# \[${VERSION}\]" CHANGELOG.md; then
            echo "ERROR: CHANGELOG.md missing entry for version ${VERSION}"
            echo ""
            echo "Expected to find a line matching: ## [${VERSION}]"
            echo ""
            echo "Available version entries in CHANGELOG.md:"
            grep -E "^\#\# \[" CHANGELOG.md | head -10
            exit 1
          fi
          echo "Found changelog entry for version ${VERSION}"

      - name: Extract latest changelog section
        run: |
          python scripts/extract_latest_changelog.py CHANGELOG.md /tmp/release_notes.md

  test:
    name: Test (tag)
    runs-on: ubuntu-latest
    needs: changelog-check
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install hatch
        run: |
          python -m pip install --upgrade pip
          pip install hatch

      - name: Run tests
        run: hatch run test:test

  build:
    name: Build package
    runs-on: ubuntu-latest
    needs: test
    outputs:
      version: ${{ steps.get_version.outputs.version }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Fetch all tags
        run: |
          git fetch --tags --force
          git describe --tags --always

      - uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install hatch
        run: |
          python -m pip install --upgrade pip
          pip install hatch

      - name: Derive version from tag
        id: get_version
        run: |
          TAG="${GITHUB_REF##*/}"
          VERSION="${TAG#v}"
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      - name: Verify clean working directory
        run: |
          git status
          git diff --stat || true

      - name: Build wheel and sdist
        run: |
          rm -rf dist/
          hatch build

      - name: Verify built version matches tag
        run: |
          EXPECTED="${{ steps.get_version.outputs.version }}"
          WHEEL=$(ls dist/*.whl | head -1)
          echo "Expected version: $EXPECTED"
          echo "Built wheel: $WHEEL"
          if [[ "$WHEEL" != *"$EXPECTED"* ]]; then
            echo "ERROR: Version mismatch!"
            echo "Wheel version does not contain expected version $EXPECTED"
            exit 1
          fi

      - name: Upload dist artifacts
        uses: actions/upload-artifact@v4
        with:
          name: dist
          path: dist/*
          retention-days: 7

  docs:
    name: Build Docs
    runs-on: ubuntu-latest
    needs: build
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: Install hatch
        run: |
          python -m pip install --upgrade pip
          pip install hatch

      - name: Build docs (tag version)
        env:
          FAPILOG_DOC_VERSION: ${{ needs.build.outputs.version }}
        run: |
          hatch run docs:build || {
            echo "Docs build failed"; exit 1;
          }

      - name: Upload docs artifact
        uses: actions/upload-artifact@v4
        with:
          name: docs-html
          path: docs/_build/html
          retention-days: 7

  publish:
    name: Publish to PyPI
    runs-on: ubuntu-latest
    needs: build
    steps:
      - uses: actions/download-artifact@v4
        with:
          name: dist
          path: dist

      - name: Publish to PyPI
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          print-hash: true
          skip-existing: false

  pages:
    name: Deploy Docs to Pages
    runs-on: ubuntu-latest
    needs: docs
    steps:
      - uses: actions/download-artifact@v4
        with:
          name: docs-html
          path: docs-html

      - name: Deploy to GitHub Pages
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./docs-html
          force_orphan: false
          user_name: 'github-actions[bot]'
          user_email: 'github-actions[bot]@users.noreply.github.com'
          commit_message: "docs: release ${{ needs.build.outputs.version }}"

  github-release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    needs: build
    steps:
      - uses: actions/checkout@v4
      - uses: actions/download-artifact@v4
        with:
          name: dist
          path: dist

      - name: Extract latest changelog section
        run: |
          python scripts/extract_latest_changelog.py CHANGELOG.md RELEASE_NOTES.md

      - name: Check if release exists
        id: check_release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          TAG="${GITHUB_REF##*/}"
          if gh release view "$TAG" > /dev/null 2>&1; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "Release $TAG already exists, will upload assets only"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "Release $TAG does not exist, will create"
          fi

      - name: Create Release
        if: steps.check_release.outputs.exists == 'false'
        uses: softprops/action-gh-release@v1
        with:
          tag_name: ${{ github.ref }}
          name: Release ${{ needs.build.outputs.version }}
          draft: false
          prerelease: false
          body_path: RELEASE_NOTES.md
          files: |
            dist/*.whl
            dist/*.tar.gz

      - name: Upload assets to existing release
        if: steps.check_release.outputs.exists == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          TAG="${GITHUB_REF##*/}"
          gh release upload "$TAG" dist/*.whl dist/*.tar.gz --clobber

  discord-announce:
    name: Announce on Discord
    runs-on: ubuntu-latest
    needs: [build, github-release]
    if: ${{ vars.DISCORD_ANNOUNCEMENTS_ENABLED == 'true' }}
    steps:
      - uses: actions/checkout@v4

      - name: Extract release notes
        run: |
          python scripts/extract_latest_changelog.py CHANGELOG.md RELEASE_NOTES.md

      - name: Post to Discord
        env:
          DISCORD_BOT_TOKEN: ${{ secrets.DISCORD_BOT_TOKEN }}
          DISCORD_CHANNEL_ID: ${{ secrets.DISCORD_CHANNEL_ID }}
          VERSION: ${{ needs.build.outputs.version }}
        run: |
          RELEASE_URL="https://github.com/${{ github.repository }}/releases/tag/v${VERSION}"

          # Generate embed payload
          PAYLOAD=$(python scripts/format_discord_release.py RELEASE_NOTES.md "${VERSION}" "${RELEASE_URL}")

          echo "Payload:"
          echo "$PAYLOAD" | jq .

          # Post to Discord
          RESPONSE=$(curl -s -X POST \
            "https://discord.com/api/v10/channels/${DISCORD_CHANNEL_ID}/messages" \
            -H "Authorization: Bot ${DISCORD_BOT_TOKEN}" \
            -H "Content-Type: application/json" \
            -d "$PAYLOAD")

          # Extract message ID for crosspost
          MESSAGE_ID=$(echo "$RESPONSE" | jq -r '.id')

          if [ "$MESSAGE_ID" == "null" ] || [ -z "$MESSAGE_ID" ]; then
            echo "Failed to post message to Discord:"
            echo "$RESPONSE"
            exit 1
          fi

          echo "Posted message ID: $MESSAGE_ID"

          # Publish/crosspost the message (for announcement channels)
          CROSSPOST_RESPONSE=$(curl -s -X POST \
            "https://discord.com/api/v10/channels/${DISCORD_CHANNEL_ID}/messages/${MESSAGE_ID}/crosspost" \
            -H "Authorization: Bot ${DISCORD_BOT_TOKEN}" \
            -H "Content-Type: application/json")

          # Check if crosspost succeeded (it's OK if it fails for non-announcement channels)
          CROSSPOST_ID=$(echo "$CROSSPOST_RESPONSE" | jq -r '.id')
          if [ "$CROSSPOST_ID" != "null" ] && [ -n "$CROSSPOST_ID" ]; then
            echo "Message published to followers"
          else
            echo "Note: Message posted but not published (channel may not be an announcement channel)"
          fi
